---
layout: single
title: Egghunter for Linux x86
date: 2019-9-30
classes: wide
header:
  teaser: /assets/images/SLAE32/shellcoding32.png
tags:
  - Assembly
  - Pentester Academy
  - SLAE32
  - Egghunter
  - Certifications
--- 
![](/assets/images/SLAE32/shellcoding32.png)

## Introduction
Why we are studiyng shellcoding? Because we want to inject our shellcodes in order to gain access to the victim machine.<br>
There are many ways to do it, the basic way is to use a bugged program to take control of his execution flow through the EIP register using buffer overflow of the stack in the memory. Explain how a buffer overflow works is out of the scope of this article. we assume that you already know how it works. If you don't, before proceed to read the entire post, we suggest you to check this precious resources to learn how a buffer overflow works:
- [The phrack "Smashing the stak for fun and profit"](www-inst.eecs.berkeley.edu/~cs161/fa08/papers/stack_smashing.pdf)
- [The Shellcode Handbook](https://doc.lagout.org/security/The%20Shellcoder%E2%80%99s%20Handbook.pdf)
- [Computer Security: A Hands-on approach](http://www.cis.syr.edu/~wedu/seed/Book/book_sample_buffer.pdf)
- [My Github Buffer Overflow Doc section](https://github.com/bolonobolo/buffer_overflow/tree/master/documentation)
- [My slides on Buffer Overflow Speach for Hackit 0x16 event](https://github.com/bolonobolo/buffer_overflow/blob/master/documentation/Basic%20Buffer%20Overflow.pdf)

Well, if you are here we can continue. What appens when you are controlling the EIP register or the SEH chain but you noticed that you haven't enough space to place your shellcode? 
![](/assets/images/SLAE32/assignment_3/BO_0.png)<br>
IN this case the workflow is not linear and we have a problem of space. There are many ways to solve this problem, one of this is to use a "placeholder" placed in a non defined portion of memory, which signals that ours shellcode start soon after the "placeholder". This technique is called ```Egghunter```.<br>


