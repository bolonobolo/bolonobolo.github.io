---
layout: single
title: SLAE32 - Assignment 0x01
date: 2019-9-19
classes: wide
header:
  teaser: /assets/images/OSCP/pwk.png
tags:
  - Penetration Testing
  - OSCP
  - PWK
  - Offensive Security
  - Review
--- 
![](/assets/images/SLAE32/shellcoding32.png)

## Introduction
This is the first assignment from Viviek Rmachandran's SLAE32 course.<br>
The first part of the assignment request to create a Shell_Bind_TCP shellcode with these properties:
- Binds to a port 
- Execs Shell on incoming connecton

The second part request to create a script to make port number easily configurable.<br>
According with [Infosec Institute](https://resources.infosecinstitute.com/icmp-reverse-shell/), bind shell could be compared to the olds backdoors placed by programmers to always have a preferential access to systems.
> *Bind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machineâ€™s listener which then leads to code or command execution on the server.* <br>

The last video lesson of SLAE course analyzes a tcp bind shell payload created with msfvenom so the creation process is well documented, well known and the shell structure too, so the effort for this assignment is to pickup infos about all the syscalls needed for the tcp bind shell using the linux kernel unistd.h header and the ```man 2``` command.
We will use also the book 
[Unix Network Programming](https://www.amazon.com/UNIX-Network-Programming-Richard-Stevens/dp/0139498761)
, that is foundamental to learn the substructures required in some syscalls.
Starting review the case study in the course, taking the png created with sctest of libemu tool suite, we can extract the elements needed to build our bind shellcode:

- socket
- bind
- listen
- accept
- dup2 (3 times)
- execve

i can simply copy the assembly code, but this is not the scope of the Viviek's assignment. What he would to intend with the assignment is to understand how the student should develop a shellcode starting from sudying the linux syscalls, what they need to complete assignment and how they can transform the syscall and its argument in assembly code.
So let's start the fun part.

## SOCKET
We can start searching the socket syscall by cat'ting the unistd_32 headers of the linux kernel, then check the socket syscall man page.<br>
![](/assets/images/SLAE32/assignment_1/socket_1.png)<br>
```C
man 2 socket
```
```C
int socket(int domain, int type, int protocol);
```
Mmm, seems the socket accept 3 arguments, let we check also the book to learn what's the role of there arguments.<br>
```int domain``` specifies a communication domain, this means that it specifies the Address Family (AF_xxxx) wich will be used for communication.<br>
```int type``` specifies the communication semantics.<br>
Not all combinations of socket domain and type are valid, we want a TCP bind shell, so according to the book, our choices has to be ```AF_INET``` for the domain and ```SOCKET_STREAM``` for the type.<br>
![](/assets/images/SLAE32/assignment_1/socket_0.png)<br>
According to what we have studied in the course, the infos found with the ```man 2``` command has to be distriuited with this criteria.
Syscall number have to go in the EAX register, ```int domain``` should be ```AF_INET```, this means a value of 2 saved in the EBX register, ```int type``` should be ```SOCK_STREAM```, this means a value of 1 saved in the ECX register, last ```int protocol``` should be 0 and placed in EDX register.<br>
![](/assets/images/SLAE32/assignment_1/socket_2.png)
![](/assets/images/SLAE32/assignment_1/socket_3.png)<br>
Now that we have indentified the socket syscall arguments, what have to be they values and in what register they has to be pushed we can proceed writing the assembly code.

```bash
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx
mov cl, 0x1
mov bl, 0x2
mov ax, 0x167
int 0x80
```
The output of socket is the the pointer to the socket and will be stored in EAX register, so in order to recover the pointer to the socket for future uses we have to move it in a safer place like the EDI register.

```bash
mov edi, eax
```
Well, we can move to the next syscall.

## BIND
As for ```bind``` we need to find the value of the syscall and consult the man page.
![](/assets/images/SLAE32/assignment_1/bind_0.png)<br>
syscall code for ```bind``` is 361, in hexadecimal is 169. Let see the ```man 2 bind``` page
```C
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
Very interesting, here we have a data structure called ```sockaddr```, let we read the book to see if it can help us understand how this data structure has to be build.
>*Many of the BSD networking system calls require a pointer to a socket address structure as an argument. The definition of this structure is in sys/socket.h*<br>

Checking the ```man 2 bind``` page we see that ```sockaddr``` structure is defined like this
```C
struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
           }
```
The contents of the 14 bytes of protocol-specific address are interpreted accordinf to the type of address. We already choosed the type in the ```socket``` syacall.
```AF_INET``` was our choice so an Address Family INtErneT. Checking ```man 7 ip``` and the book to learn that in this case the ```sockaddr_in``` structure has to be build like this

```C
struct sockaddr_in {
               sa_family_t    sin_family; /* address family: AF_INET */
               in_port_t      sin_port;   /* port in network byte order */
               struct in_addr sin_addr;   /* internet address */
           };

           /* Internet address. */
           struct in_addr {
               uint32_t       s_addr;     /* address in network byte order */
           };

```
So for our purpouses we have to build a structure like the above and to do that we can use the stack. 
Before enter in the details let's we checks what we need for ```bind``` syscall and where we have to put things
![](/assets/images/SLAE32/assignment_1/bind_1.png)<br>
We will push all the values needed

