---
layout: single
title: SLAE32 - Assignment 0x01
date: 2019-9-19
classes: wide
header:
  teaser: /assets/images/OSCP/pwk.png
tags:
  - Penetration Testing
  - OSCP
  - PWK
  - Offensive Security
  - Review
--- 
![](/assets/images/SLAE32/shellcoding32.png)

## Introduction
This is the first assignment from Viviek Rmachandran SLAE32 course.<br>
The first part of the assignment request to create a Shell_Bind_TCP shellcode with these properties:
- Binds to a port 
- Execs Shell on incoming connecton

The second part request to create a script to make port number easily configurable.<br>
According with +[Infosec Institute](https://resources.infosecinstitute.com/icmp-reverse-shell/), bind shell could be compared to the olds backdoors placed by programmers to always have a preferential access to systems.
> *Bind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machineâ€™s listener which then leads to code or command execution on the server.* <br>

The last video lesson of SLAE course analyzes a tcp bind shell payload created with msfvenom so the creation process is well documented, well known and the shell structure too, so the effort for this assignment is to pickup infos about all the syscalls needed for the tcp bind shell using the linux kernel unistd.h header and the man 2 <syscall> command.
Starting review the case study in the course, taking the png created with sctest of libemu tool suite, we can extract the elements needed to build our bind shellcode:

- socket
- bind
- listen
- accept
- dup2 (3 times)
- execve

i can simply copy the assembly code, but this is not the scope of the viviek's assignment. What he would to intend with the assignment is to understand how the student should develop a shellcode starting from sudying the linux syscalls, what they need to complete assignment and how they can transform the syscall and its argument in assembly code.
So let's start the fun part.

## SOCKET
We can start searching the socket syscall by cat'ting the unistd_32 headers of the linux kernel 
![](/assets/images/SLAE32/assignment_1/socket_1.png)
Now let's check the classic syscall man page
![](/assets/images/SLAE32/assignment_1/socket_2.png)
![](/assets/images/SLAE32/assignment_1/socket_3.png)
Mmm, seems the socket accept 3 arguments.<br>
According to what we have studied in the course the infos found with the ```man 2``` command has to be distriuited with this criteria.
Syscall number have to go in the EAX register, we want a TCP shell so ```int domain``` should be ```AF_INET```, this means a value of 2 saved in the EBX register, ```int type``` should be SOCK_STREAM, this means a value of 1 saved in the ECX register, last ```int protocol``` should be 0 and placed in EDX register.
Now that we have indentified the socket syscall arguments, what have to be they values and in what register they has to be pushed we can proceed writing the assembly code.

```asm
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx
mov cl, 0x1
mov bl, 0x2
mov ax, 0x167
int 0x80
```
The output of socket will be stored in eax register so in order to recover the pointer to the socket we can move it in the edi register.

```asm
mov edi, eax
```

