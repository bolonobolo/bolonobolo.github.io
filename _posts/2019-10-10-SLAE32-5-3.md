---
layout: single
title: Msfvenom Exec Payload Analysis
date: 2019-10-10
classes: wide
header:
  teaser: /assets/images/SLAE32/shellcoding32.png
tags:
  - Assembly
  - Pentester Academy
  - SLAE32
  - Shellcode
  - Certifications
--- 
![](/assets/images/SLAE32/shellcoding32.png)

## Introduction
If we search on internet we will find a lot of ready to use shellcodes of various types, somes are for simple command execution, others adds "secret users" in victim machine, others are bind and reverse shell like the shellcodes wrote in this blog. The question is, shall we trust shellcodes found in internet? Following the general rule "Trust no one" the answer should be a big No, but sometime, for example when we have limited time, we prefer or we are forced to use others shellcode.<br>
In this cases what we suggest is to analyze the downloaed shellcode in sandbox machine before use it, to ensure that it will do what it declare.<br>
For this post we want to show how to analyze 3 samples of shellcodes took from msfvenom payload tool.
We can use the msfvenom tool to list payloads that could be produced:
```bash
root@slae32-lab:# msfvenom -l payloads |grep linux/x86
```
![](/assets/images/SLAE32/assignment_5/analysis_0.png)<br>
We have already build (and analyzed) the bind and reverse shellcode types so we choosed this 3 shellcode samples:
- [linux/x86/adduser](https://blackcloud.me/SLAE32-5-1/) "Create a new user with UID 0"
- [linux/x86/chmod](https://blackcloud.me/SLAE32-5-2/) "Runs chmod on specified file with specified mode"
- linux/x86/exec "Execute an arbitrary command"

So let's start our analysis

## Exec
First thing, we must create the payload with msfvenom
```bash
root@slae32-lab:# msfvenom -p linux/x86/exec CMD=id -f C -a x86 --platform linux
No encoder or badchars specified, outputting raw payload
Payload size: 38 bytes
Final size of c file: 185 bytes
unsigned char buf[] = 
"\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68"
"\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x03\x00\x00\x00\x69"
"\x64\x00\x57\x53\x89\xe1\xcd\x80";

```
Now we need to analyze it with ndisasm, using the command 
```bash
root@slae32-lab:# echo -ne "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x03\x00\x00\x00\x69\x64\x00\x57\x53\x89\xe1\xcd\x80" | ndisasm -u -
```
We have one syscall also in this case, the execve 
![](/assets/images/SLAE32/assignment_5/execve_0.png)<br>
![](/assets/images/SLAE32/assignment_5/execve_1.png)<br> 
We have already saw the execve syscall, let's resume it:
- EAX register contains the ```execve``` syscall hexadecimal value (11 or 0xb)
- EBX register contains the pointer to the ```filename``` that should be executed, in our case ```/bin/id```, reverted because we are working in little endian environment.
- ECX contains a pointer to ```argv``` that is an array of argument strings passed to the new program, in our case is the address of the filename to execute, the ```argv[0]```
- EDX contains a pointer to ```envp``` that is an array of strings of the form key=value wich are passed as environment to the new program.<br>

Tha man page tell us also the all the 3 arguments are pointer, because we are talking about pointer to strings we need to remember that all the arguments has to terminate with a NULL char.
The ```argv``` should contain the address of the ```filename```, but we also have to add a NULL char as terminating char
We don't need ```envp``` so EDX could be set to 0.
We can use the stack to work with all this information and then save the structure in the relative registers, taking in consideration that we have to work in reverse mode because of the little endian.
We will use the stack method to execute the ```execve``` syscall.<br>
We will load the shellcode in our C code executor, compile it and debug it.<br>
```C
#include<stdio.h>
#include<string.h>

unsigned char code[] = \
"\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68"
"\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x03\x00\x00\x00\x69"
"\x64\x00\x57\x53\x89\xe1\xcd\x80";

void main()
{

        printf("Shellcode Length:  %d\n", strlen(code));

        int (*ret)() = (int(*)())code;

        ret();

}
```
![](/assets/images/SLAE32/assignment_5/execve_2.png)<br> 

We will explain the code
```nasm
push   0xb			        ; execve() syscall		
pop    eax			        ; 
cdq    				        ; set edx to 0
push   edx			        ; push 0 on the stack
pushw  0x632d			    ; push '-c' on the stack
mov    edi,esp			    ; point edi to stack
push   0x68732f			    ; push 'hs/'
push   0x6e69622f		    ; push 'nib/'
mov    ebx,esp			    ; load the executable pointer in ebx
push   edx			        ; push 
call   0x402060 <code+32>	; call and push "id" string to stack	
imul   esp,DWORD PTR 		; "id" string
push   ebx			        ; push "/bin/sh"
mov    ecx,esp			    ; point to stack
int    0x80			        ; execute execve
```
```nasm
Dump of assembler code for function code:
=> 0x0804a040 <+0>:	    push   0xb
   0x0804a042 <+2>:	    pop    eax
   0x0804a043 <+3>:	    cdq    
   0x0804a044 <+4>:	    push   edx
   0x0804a045 <+5>:	    pushw  0x632d
   0x0804a049 <+9>:	    mov    edi,esp
   0x0804a04b <+11>:	push   0x68732f
   0x0804a050 <+16>:	push   0x6e69622f
   0x0804a055 <+21>:	mov    ebx,esp
   0x0804a057 <+23>:	push   edx
   0x0804a058 <+24>:	call   0x804a060 <code+32>
   0x0804a05d <+29>:	imul   esp,DWORD PTR [eax+eax*1+0x57],0xcde18953
   0x0804a065 <+37>:	add    BYTE PTR [eax],0x0
```